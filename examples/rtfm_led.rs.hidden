#![no_main]
#![no_std]

// extern crate panic_semihosting;
extern crate panic_halt;
// use cortex_m_semihosting::dbg;

use lpc55s6x_hal as hal;
use hal::{
    prelude::*,
    gpio::{self, Level},
    iocon,
};

#[rtfm::app(device = crate::hal::raw, peripherals = true)]
const APP: () = {
    struct Resources {
        led: iocon::Pin<iocon::PIO1_6, iocon::pin_state::Gpio<gpio::direction::Output>>,
        delay: hal::clock::Ticks<'static, hal::syscon::Fro1MhzUtickClock<hal::init_state::Enabled>>,
        sleep: hal::sleep::Busy<'static>,
    }

    #[init]
    fn init(c: init::Context) -> init::LateResources {
        // dbg!("init");
        let _cp = c.core;
        let dp = c.device;

        // setup red LED
        let mut syscon = hal::syscon::SYSCON::new(dp.SYSCON).split();
        let mut gpio = hal::gpio::GPIO::new(dp.GPIO).enable(&mut syscon.handle);
        let iocon = hal::iocon::IOCON::new(dp.IOCON).split();

        let red_led = iocon.pins.pio1_6
            .into_gpio_pin(&mut gpio)
            .into_output(Level::High);

        let clock = syscon.fro_1mhz_utick_clock.enable(&mut syscon.handle);
        let delay = hal::clock::Ticks {
            value: 500_000,
            clock: &clock,
        }; // 500 ms = 0.5 s

        let mut utick = dp.UTICK.enable(&mut syscon.handle);
        let mut sleep = hal::sleep::Busy::prepare(&mut utick);

        init::LateResources {
            led: red_led,
            delay,
            sleep,
        }
    }

    #[idle(resources = [led, delay, sleep])]
    fn idle(c: idle::Context) -> ! {
        let led = c.resources.led;
        loop {
            // dbg!("low");
            led.set_low().unwrap();
            c.resources.sleep.sleep(c.resources.delay);

            // dbg!("high");
            led.set_high().unwrap();
            c.resources.sleep.sleep(c.resources.delay);
        }
    }
};
